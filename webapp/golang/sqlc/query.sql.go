// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const getPostRecentCommentsAndUser = `-- name: GetPostRecentCommentsAndUser :many
SELECT ranked.id, ranked.post_id, ranked.created_at, ranked.comment, ranked.user_id, CAST(ranking as UNSIGNED ),
    u.account_name, u.authority, u.del_flg
FROM (
         SELECT c.id, c.post_id, c.created_at, c.comment, c.user_id,
                RANK() OVER (PARTITION BY post_id ORDER BY created_at DESC ) AS ranking
         FROM comments as c
         WHERE c.post_id IN (/*SLICE:post_ids*/?)
     ) as ranked
         LEFT JOIN users as u ON ranked.user_id = u.id
WHERE ranking <= 3
ORDER BY ranked.post_id, ranking DESC
`

type GetPostRecentCommentsAndUserRow struct {
	ID          int32
	PostID      int32
	CreatedAt   time.Time
	Comment     string
	UserID      int32
	Ranking     int64
	AccountName sql.NullString
	Authority   sql.NullBool
	DelFlg      sql.NullBool
}

func (q *Queries) GetPostRecentCommentsAndUser(ctx context.Context, postIds []int32) ([]GetPostRecentCommentsAndUserRow, error) {
	query := getPostRecentCommentsAndUser
	var queryParams []interface{}
	if len(postIds) > 0 {
		for _, v := range postIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:post_ids*/?", strings.Repeat(",?", len(postIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:post_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostRecentCommentsAndUserRow
	for rows.Next() {
		var i GetPostRecentCommentsAndUserRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.CreatedAt,
			&i.Comment,
			&i.UserID,
			&i.Ranking,
			&i.AccountName,
			&i.Authority,
			&i.DelFlg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUndeletedUsersPosts = `-- name: GetUndeletedUsersPosts :many
SELECT p.id, p.user_id, p.mime, p.body, p.created_at,
       account_name, passhash, authority, del_flg
FROM posts as p
         LEFT JOIN users u on u.id = p.user_id
WHERE u.del_flg = 0
ORDER BY p.created_at DESC
LIMIT ?
`

type GetUndeletedUsersPostsRow struct {
	ID          int32
	UserID      int32
	Mime        string
	Body        string
	CreatedAt   time.Time
	AccountName string
	Passhash    string
	Authority   bool
	DelFlg      bool
}

func (q *Queries) GetUndeletedUsersPosts(ctx context.Context, limit int32) ([]GetUndeletedUsersPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUndeletedUsersPosts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUndeletedUsersPostsRow
	for rows.Next() {
		var i GetUndeletedUsersPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Mime,
			&i.Body,
			&i.CreatedAt,
			&i.AccountName,
			&i.Passhash,
			&i.Authority,
			&i.DelFlg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
